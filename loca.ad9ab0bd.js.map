{"version":3,"sources":["node_modules/lib-font/src/opentype/tables/simple/ttf/loca.js"],"names":["loca","SimpleTable","constructor","dict","dataview","tables","p","n","maxp","numGlyphs","hmtx","indexToLocFormat","x2","Array","map","_","Offset16","Offset32","getGlyphDataOffsetAndLength","glyphID","offset","offsets","nextOffset","length"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAN,SAAmBC,wBAAnB,CAA+B;AAC7BC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiBC,MAAjB,EAAyB;AAClC,UAAM;AAAEC,MAAAA;AAAF,QAAQ,MAAMH,IAAN,EAAYC,QAAZ,CAAd;AAEA,UAAMG,CAAC,GAAGF,MAAM,CAACG,IAAP,CAAYC,SAAZ,GAAwB,CAAlC,CAHkC,CAGG;;AAErC,QAAIJ,MAAM,CAACK,IAAP,CAAYC,gBAAZ,KAAiC,CAArC,EAAwC;AACtC,WAAKC,EAAL,GAAU,IAAV;AACA,yBAAK,IAAL,EAAY,SAAZ,EAAsB,MAAM,CAAC,GAAG,IAAIC,KAAJ,CAAUN,CAAV,CAAJ,EAAkBO,GAAlB,CAAuBC,CAAD,IAAOT,CAAC,CAACU,QAA/B,CAA5B;AACD,KAHD,MAGO;AACL,yBAAK,IAAL,EAAY,SAAZ,EAAsB,MAAM,CAAC,GAAG,IAAIH,KAAJ,CAAUN,CAAV,CAAJ,EAAkBO,GAAlB,CAAuBC,CAAD,IAAOT,CAAC,CAACW,QAA/B,CAA5B;AACD;AACF;;AAEDC,EAAAA,2BAA2B,CAACC,OAAD,EAAU;AACnC,QAAIC,MAAM,GAAG,KAAKC,OAAL,CAAaF,OAAb,IAAwB,KAAKP,EAA7B,GAAkC,CAAlC,GAAsC,CAAnD;AACA,QAAIU,UAAU,GAAG,KAAKD,OAAL,CAAaF,OAAO,GAAG,CAAvB,IAA4B,KAAKP,EAAjC,GAAsC,CAAtC,GAA0C,CAA3D;AACA,WAAO;AAAEQ,MAAAA,MAAF;AAAUG,MAAAA,MAAM,EAAED,UAAU,GAAGF;AAA/B,KAAP;AACD;;AAlB4B","file":"loca.ad9ab0bd.js","sourceRoot":"..","sourcesContent":["import { SimpleTable } from \"../../simple-table.js\";\nimport lazy from \"../../../../lazy.js\";\n\n/**\n * The OpenType `loca` table.\n *\n * See https://docs.microsoft.com/en-us/typography/opentype/spec/loca\n */\nclass loca extends SimpleTable {\n  constructor(dict, dataview, tables) {\n    const { p } = super(dict, dataview);\n\n    const n = tables.maxp.numGlyphs + 1; // \"plus one\" because the offset list needs one extra element to determine the block length for the last supported glyph.\n\n    if (tables.hmtx.indexToLocFormat === 0) {\n      this.x2 = true;\n      lazy(this, `offsets`, () => [...new Array(n)].map((_) => p.Offset16));\n    } else {\n      lazy(this, `offsets`, () => [...new Array(n)].map((_) => p.Offset32));\n    }\n  }\n\n  getGlyphDataOffsetAndLength(glyphID) {\n    let offset = this.offsets[glyphID] * this.x2 ? 2 : 1;\n    let nextOffset = this.offsets[glyphID + 1] * this.x2 ? 2 : 1;\n    return { offset, length: nextOffset - offset };\n  }\n}\n\nexport { loca };\n"]}